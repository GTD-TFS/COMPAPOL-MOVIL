<!doctype html>
<html lang="es">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Compapol ¬∑ Dictado ‚Üí Comparecencia</title>
  <style>
    body { margin:0; font-family:system-ui, -apple-system, Segoe UI, Roboto, Arial; background:#0b1220; color:#e5e7eb; }
    header { position:sticky; top:0; background:#111827; padding:12px 16px; border-bottom:1px solid #28324a; z-index:10; }
    h1 { margin:0; font-size:18px; }
    .wrap { padding:14px; max-width:720px; margin:0 auto; }
    .row { display:grid; gap:10px; grid-template-columns:1fr 1fr; }
    .row-3 { display:grid; gap:10px; grid-template-columns:1fr 1fr 1fr; }
    .btn { width:100%; padding:14px; border:1px solid #28324a; border-radius:12px; background:#1f2937; color:#e5e7eb; font-size:16px; }
    .btn:active { transform:scale(.99); }
    .ok { border-color:#16a34a; }
    .warn { border-color:#f59e0b; }
    .danger { border-color:#ef4444; }
    textarea { width:100%; min-height:160px; padding:12px; border-radius:12px; border:1px solid #28324a; background:#0f172a; color:#e5e7eb; font-size:15px; }
    .out { min-height:200px; background:#0f172a; border:1px solid #28324a; border-radius:12px; padding:12px; }
    .muted { color:#9ca3af; font-size:13px; }
    .status { font-size:13px; margin-top:6px; min-height:18px; }
    .hidden { display:none; }
    @media (max-width:520px){
      .row, .row-3 { grid-template-columns:1fr; }
    }
  </style>
</head>
<body>
  <header><h1>COMPAPOL ¬∑ Dictado ‚Üí Comparecencia</h1></header>
  <div class="wrap">

    <!-- Controles principales -->
    <div class="row-3" style="margin-bottom:10px;">
      <button id="btnMic" class="btn">üé§ Dictar (continuo)</button>
      <button id="btnStop" class="btn danger">‚èπÔ∏è Parar</button>
      <button id="btnNuevo" class="btn">üîÑ Nuevo</button>
    </div>

    <!-- Grabaci√≥n para servidor (funciona en iOS/Android) -->
    <div class="row-3" style="margin-bottom:10px;">
      <button id="btnRec" class="btn">üéß Grabar (servidor)</button>
      <button id="btnRecStop" class="btn danger">‚èπÔ∏è Parar grabaci√≥n</button>
      <button id="btnSubir" class="btn">‚¨ÜÔ∏è Subir audio</button>
      <input id="fileAudio" class="hidden" type="file" accept="audio/*">
    </div>

    <div class="row" style="margin-bottom:10px;">
      <button id="btnRedactar" class="btn ok">üõ°Ô∏è Redactar estilo policial (API)</button>
    </div>

    <p class="muted">Revisa el texto transcrito antes de convertirlo. El dictado es continuo y s√≥lo se detiene al pulsar ‚ÄúParar‚Äù. En iPhone usa ‚ÄúGrabar (servidor)‚Äù.</p>

    <textarea id="txtDictado" placeholder="Texto dictado (editable para corregir)‚Ä¶"></textarea>
    <div class="status" id="status"></div>

    <h3>Salida</h3>
    <div id="salida" class="out"></div>
  </div>

  <script>
    // Cambia aqu√≠ si mueves el backend
    const API_BASE = "https://compa-movil-backend.onrender.com";

    (async function(){
      const $ = (s)=>document.querySelector(s);
      const btnMic = $('#btnMic');
      const btnStop = $('#btnStop');
      const btnNuevo = $('#btnNuevo');
      const btnRec = $('#btnRec');
      const btnRecStop = $('#btnRecStop');
      const btnSubir = $('#btnSubir');
      const fileAudio = $('#fileAudio');
      const txtDictado = $('#txtDictado');
      const salida = $('#salida');
      const status = $('#status');

      // Carga de datos previos
      function loadJSON(key, fallback){
        try { return JSON.parse(localStorage.getItem(key) || JSON.stringify(fallback)); }
        catch(e){ return fallback; }
      }
      const filiaciones = loadJSON("compapol.filiaciones", []);
      const objetos     = loadJSON("compapol.objetos", []);

      // ====== Opci√≥n 1: Dictado continuo con Web Speech API (Android/Chrome) ======
      let recognition = null;
      let manuallyStopped = false;
      const SR = window.SpeechRecognition || window.webkitSpeechRecognition;

      if (SR) {
        recognition = new SR();
        recognition.lang = 'es-ES';
        recognition.interimResults = false;
        recognition.maxAlternatives = 1;
        recognition.continuous = true; // modo continuo

        recognition.onstart = ()=>{
          status.textContent = 'üéôÔ∏è Dictando (continuo)‚Ä¶ Pulsa ‚èπÔ∏è Parar para detener.';
        };
        recognition.onresult = (e)=>{
          let chunk = '';
          for (let i = e.resultIndex; i < e.results.length; i++) {
            const t = e.results[i][0]?.transcript || '';
            if (t) chunk += (t.trim() + ' ');
          }
          if (chunk) {
            txtDictado.value = (txtDictado.value ? (txtDictado.value.trim() + ' ') : '') + chunk.trim();
          }
        };
        recognition.onerror = (e)=>{
          status.textContent = '‚ö†Ô∏è Error micro: ' + (e.error || 'desconocido');
        };
        recognition.onend = ()=>{
          // Si el navegador corta, relanzamos salvo que el usuario haya parado.
          if (!manuallyStopped) {
            try { recognition.start(); } catch {}
          } else {
            status.textContent = 'üõë Dictado detenido.';
          }
        };
      } else {
        // iOS/Safari no soporta SpeechRecognition
        btnMic.classList.add('warn');
        btnMic.textContent = 'üé§ No disponible (usa ‚ÄúGrabar (servidor)‚Äù)';
      }

      btnMic.addEventListener('click', ()=>{
        if (!recognition) { status.textContent = 'Este navegador no permite dictado directo.'; return; }
        manuallyStopped = false;
        try { recognition.start(); } catch(e){ /* ignore double start */ }
      });

      btnStop.addEventListener('click', ()=>{
        if (recognition) {
          manuallyStopped = true;
          try { recognition.stop(); } catch {}
        }
      });

      btnNuevo.addEventListener('click', ()=>{
        txtDictado.value = '';
        salida.innerHTML = '';
        status.textContent = 'üßπ Campos limpios. Listo para nuevo dictado.';
      });

      // ====== Opci√≥n 2: Grabaci√≥n con MediaRecorder ‚Üí servidor (iOS/Android) ======
      let mediaRecorder = null;
      let recChunks = [];
      let recStream = null;

      async function startRecording() {
        try {
          recStream = await navigator.mediaDevices.getUserMedia({ audio: true });
          const mime = MediaRecorder.isTypeSupported('audio/webm') ? 'audio/webm'
                     : MediaRecorder.isTypeSupported('audio/mp4')  ? 'audio/mp4'
                     : 'audio/webm';
          mediaRecorder = new MediaRecorder(recStream, { mimeType: mime });
          recChunks = [];

          mediaRecorder.ondataavailable = (e)=> { if (e.data && e.data.size) recChunks.push(e.data); };
          mediaRecorder.onstart = ()=> { status.textContent = 'üî¥ Grabando‚Ä¶ Pulsa ‚Äú‚èπÔ∏è Parar grabaci√≥n‚Äù para finalizar.'; };
          mediaRecorder.onerror = (e)=> { status.textContent = '‚ö†Ô∏è Error grabaci√≥n: ' + (e.error?.message || e.message || 'desconocido'); };
          mediaRecorder.onstop = async ()=>{
            try {
              const blob = new Blob(recChunks, { type: mediaRecorder.mimeType || 'audio/webm' });
              const ext  = blob.type.includes('mp4') ? 'm4a' : (blob.type.split('/')[1] || 'webm');
              const file = new File([blob], `grabacion.${ext}`, { type: blob.type });

              status.textContent = '‚è≥ Enviando audio al servidor para transcribir‚Ä¶';
              const fd = new FormData();
              fd.append('file', file, file.name);

              const r = await fetch(`${API_BASE}/api/whisper`, { method:'POST', body: fd });
              if (!r.ok) throw new Error('HTTP '+r.status);
              const { text } = await r.json();
              txtDictado.value = text || '';
              status.textContent = '‚úÖ Transcripci√≥n lista. Revisa y corrige si hace falta.';
            } catch (err) {
              status.textContent = '‚ùå Error al transcribir: ' + err.message;
            } finally {
              recStream?.getTracks()?.forEach(t=>t.stop());
              recStream = null;
              mediaRecorder = null;
              recChunks = [];
            }
          };

          mediaRecorder.start(1000); // trozos cada 1s
        } catch (err) {
          status.textContent = '‚ùå No se pudo acceder al micr√≥fono: ' + (err.message || err.name || 'permiso denegado');
        }
      }

      function stopRecording() {
        try {
          if (mediaRecorder && mediaRecorder.state !== 'inactive') {
            mediaRecorder.stop();
          } else {
            status.textContent = '‚ÑπÔ∏è No hay grabaci√≥n activa.';
          }
        } catch (e) {
          status.textContent = '‚ö†Ô∏è Error al detener grabaci√≥n.';
        }
      }

      btnRec.addEventListener('click', startRecording);
      btnRecStop.addEventListener('click', stopRecording);

      // ====== Subir archivo de audio manual ======
      btnSubir.addEventListener('click', ()=> fileAudio.click());
      fileAudio.addEventListener('change', async ()=>{
        const f = fileAudio.files?.[0];
        if (!f) return;
        status.textContent = '‚è≥ Transcribiendo audio‚Ä¶';
        try {
          const fd = new FormData();
          fd.append('file', f, f.name);
          const r = await fetch(`${API_BASE}/api/whisper`, { method:'POST', body: fd });
          if (!r.ok) throw new Error('HTTP '+r.status);
          const { text } = await r.json();
          txtDictado.value = text || '';
          status.textContent = '‚úÖ Transcripci√≥n lista. Revisa y corrige si hace falta.';
        } catch(err){
          status.textContent = '‚ùå Error al transcribir: '+err.message;
        } finally {
          fileAudio.value = '';
        }
      });

      // ====== Redacci√≥n policial ======
      $('#btnRedactar').addEventListener('click', async ()=>{
        const texto = (txtDictado.value || '').trim();
        if (!texto) { status.textContent = 'Escribe o dicta algo antes de redactar.'; return; }
        status.textContent = '‚è≥ Redactando comparecencia‚Ä¶';
        salida.innerHTML = '';
        try {
          const body = JSON.stringify({ texto, filiaciones, objetos });
          const r = await fetch(`${API_BASE}/api/police-draft`, {
            method:'POST',
            headers:{ 'Content-Type':'application/json' },
            body
          });
          if (!r.ok) throw new Error('HTTP '+r.status);
          const { html } = await r.json();
          salida.innerHTML = html || '<em>(Sin contenido devuelto)</em>';
          status.textContent = '‚úÖ Comparecencia generada.';
        } catch(err){
          status.textContent = '‚ùå Error en redacci√≥n: '+err.message;
        }
      });
    })();
  </script>
</body>
</html>
