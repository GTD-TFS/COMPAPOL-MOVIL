<!doctype html>
<html lang="es">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Compapol · Dictado → Comparecencia</title>
  <style>
    body { margin:0; font-family:system-ui, -apple-system, Segoe UI, Roboto, Arial; background:#0b1220; color:#e5e7eb; }
    header { position:sticky; top:0; background:#111827; padding:12px 16px; border-bottom:1px solid #28324a; z-index:10; }
    h1 { margin:0; font-size:18px; }
    .wrap { padding:14px; max-width:720px; margin:0 auto; }
    .row { display:grid; gap:10px; grid-template-columns:1fr 1fr; }
    .row-3 { display:grid; gap:10px; grid-template-columns:1fr 1fr 1fr; }
    .btn { width:100%; padding:14px; border:1px solid #28324a; border-radius:12px; background:#1f2937; color:#e5e7eb; font-size:16px; }
    .btn:active { transform:scale(.99); }
    .ok { border-color:#16a34a; }
    .warn { border-color:#f59e0b; }
    .danger { border-color:#ef4444; }
    textarea { width:100%; min-height:160px; padding:12px; border-radius:12px; border:1px solid #28324a; background:#0f172a; color:#e5e7eb; font-size:15px; }
    .out { min-height:200px; background:#0f172a; border:1px solid #28324a; border-radius:12px; padding:12px; }
    .muted { color:#9ca3af; font-size:13px; }
    .status { font-size:13px; margin-top:6px; min-height:18px; }
    .hidden { display:none; }
    @media (max-width:520px){
      .row, .row-3 { grid-template-columns:1fr; }
    }
  </style>
</head>
<body>
  <header><h1>COMPAPOL · Dictado → Comparecencia</h1></header>
  <div class="wrap">

    <!-- Controles principales -->
    <div class="row-3" style="margin-bottom:10px;">
      <button id="btnMic" class="btn">🎤 Dictar (continuo)</button>
      <button id="btnStop" class="btn danger">⏹️ Parar</button>
      <button id="btnNuevo" class="btn">🔄 Nuevo</button>
    </div>

    <!-- Grabación para servidor (iOS/Android compatible) -->
    <div class="row-3" style="margin-bottom:10px;">
      <button id="btnRec" class="btn">🎧 Grabar (servidor)</button>
      <button id="btnRecStop" class="btn danger">⏹️ Parar grabación</button>
      <button id="btnSubir" class="btn">⬆️ Subir audio</button>
      <!-- Importante: capture="microphone" para forzar micro nativo -->
      <input id="fileAudio" class="hidden" type="file" accept="audio/*" capture="microphone">
    </div>

    <div class="row" style="margin-bottom:10px;">
      <button id="btnRedactar" class="btn ok">🛡️ Redactar estilo policial (API)</button>
    </div>

    <p class="muted">
      Revisa el texto transcrito antes de convertirlo. El dictado es continuo y sólo se detiene al pulsar “Parar”.<br>
      En iPhone usa “Grabar (servidor)” o “Subir audio”.
    </p>

    <textarea id="txtDictado" placeholder="Texto dictado (editable para corregir)…"></textarea>
    <div class="status" id="status"></div>

    <h3>Salida</h3>
    <div id="salida" class="out"></div>
  </div>

  <script>
    // Cambia aquí si mueves el backend
    const API_BASE = "https://compa-movil-backend.onrender.com";

    (async function(){
      const $ = (s)=>document.querySelector(s);
      const btnMic = $('#btnMic');
      const btnStop = $('#btnStop');
      const btnNuevo = $('#btnNuevo');
      const btnRec = $('#btnRec');
      const btnRecStop = $('#btnRecStop');
      const btnSubir = $('#btnSubir');
      const fileAudio = $('#fileAudio');
      const txtDictado = $('#txtDictado');
      const salida = $('#salida');
      const status = $('#status');

      // Carga de datos previos
      function loadJSON(key, fallback){
        try { return JSON.parse(localStorage.getItem(key) || JSON.stringify(fallback)); }
        catch(e){ return fallback; }
      }
      const filiaciones = loadJSON("compapol.filiaciones", []);
      const objetos     = loadJSON("compapol.objetos", []);

      // ====== Opción 1: Dictado continuo con Web Speech API (Android/Chrome). iOS NO. ======
      let recognition = null;
      let manuallyStopped = false;
      const SR = window.SpeechRecognition || window.webkitSpeechRecognition;

      if (SR) {
        recognition = new SR();
        recognition.lang = 'es-ES';
        recognition.interimResults = false;
        recognition.maxAlternatives = 1;
        recognition.continuous = true; // modo continuo

        recognition.onstart = ()=>{
          status.textContent = '🎙️ Dictando (continuo)… Pulsa ⏹️ Parar para detener.';
        };
        recognition.onresult = (e)=>{
          let chunk = '';
          for (let i = e.resultIndex; i < e.results.length; i++) {
            const t = e.results[i][0]?.transcript || '';
            if (t) chunk += (t.trim() + ' ');
          }
          if (chunk) {
            txtDictado.value = (txtDictado.value ? (txtDictado.value.trim() + ' ') : '') + chunk.trim();
          }
        };
        recognition.onerror = (e)=>{
          status.textContent = '⚠️ Error micro: ' + (e.error || 'desconocido');
        };
        recognition.onend = ()=>{
          // Si el navegador corta, relanzamos salvo que el usuario haya parado.
          if (!manuallyStopped) {
            try { recognition.start(); } catch {}
          } else {
            status.textContent = '🛑 Dictado detenido.';
          }
        };
      } else {
        // iOS/Safari no soporta SpeechRecognition
        btnMic.classList.add('warn');
        btnMic.textContent = '🎤 No disponible (usa “Grabar (servidor)” o “Subir audio”)';
        // En móviles sin SR, que el botón de grabar abra directamente el selector nativo
        btnRec.addEventListener('click', ()=> fileAudio.click());
      }

      btnMic.addEventListener('click', ()=>{
        if (!recognition) { status.textContent = 'Este navegador no permite dictado directo.'; return; }
        manuallyStopped = false;
        try { recognition.start(); } catch(e){ /* ignore double start */ }
      });

      btnStop.addEventListener('click', ()=>{
        if (recognition) {
          manuallyStopped = true;
          try { recognition.stop(); } catch {}
        }
      });

      btnNuevo.addEventListener('click', ()=>{
        txtDictado.value = '';
        salida.innerHTML = '';
        status.textContent = '🧹 Campos limpios. Listo para nuevo dictado.';
      });

      // ====== Opción 2: Grabación con MediaRecorder → servidor (iOS/Android) ======
      let mediaRecorder = null;
      let recChunks = [];
      let recStream = null;

      async function startRecording() {
        try {
          recStream = await navigator.mediaDevices.getUserMedia({ audio: true });

          // Elegir mime compatible; Safari se lleva mejor sin forzar si duda
          let mime = '';
          if (window.MediaRecorder && MediaRecorder.isTypeSupported) {
            if (MediaRecorder.isTypeSupported('audio/mp4'))  mime = 'audio/mp4';
            else if (MediaRecorder.isTypeSupported('audio/webm')) mime = 'audio/webm';
          }
          mediaRecorder = mime ? new MediaRecorder(recStream, { mimeType: mime })
                               : new MediaRecorder(recStream);

          recChunks = [];

          mediaRecorder.ondataavailable = (e)=> { if (e.data && e.data.size) recChunks.push(e.data); };
          mediaRecorder.onstart = ()=> { status.textContent = '🔴 Grabando… Pulsa “⏹️ Parar grabación” para finalizar.'; };
          mediaRecorder.onerror = (e)=> { status.textContent = '⚠️ Error grabación: ' + (e.error?.message || e.message || 'desconocido'); };
          mediaRecorder.onstop = async ()=>{
            try {
              const type = mediaRecorder.mimeType || (recChunks[0]?.type) || 'audio/mp4';
              const blob = new Blob(recChunks, { type });
              const ext  = type.includes('mp4') ? 'm4a'
                         : type.includes('webm') ? 'webm'
                         : type.includes('wav') ? 'wav'
                         : 'm4a';
              const file = new File([blob], `grabacion.${ext}`, { type });

              status.textContent = '⏳ Enviando audio al servidor para transcribir…';
              const fd = new FormData();
              fd.append('file', file, file.name);

              const r = await fetch(`${API_BASE}/api/whisper`, { method:'POST', body: fd });
              if (!r.ok) {
                let msg = 'HTTP ' + r.status;
                try { const j = await r.json(); if (j?.error) msg += ' · ' + j.error; } catch {}
                throw new Error(msg);
              }
              const { text } = await r.json();
              txtDictado.value = text || '';
              status.textContent = '✅ Transcripción lista. Revisa y corrige si hace falta.';
            } catch (err) {
              status.textContent = '❌ Error al transcribir: ' + err.message;
            } finally {
              recStream?.getTracks()?.forEach(t=>t.stop());
              recStream = null;
              mediaRecorder = null;
              recChunks = [];
            }
          };

          mediaRecorder.start(1000); // trozos cada 1s
        } catch (err) {
          status.textContent = '❌ No se pudo acceder al micrófono: ' + (err.message || err.name || 'permiso denegado');
        }
      }

      function stopRecording() {
        try {
          if (mediaRecorder && mediaRecorder.state !== 'inactive') {
            mediaRecorder.stop();
          } else {
            status.textContent = 'ℹ️ No hay grabación activa.';
          }
        } catch (e) {
          status.textContent = '⚠️ Error al detener grabación.';
        }
      }

      btnRec.addEventListener('click', startRecording);
      btnRecStop.addEventListener('click', stopRecording);

      // ====== Subir archivo de audio manual (abre grabadora nativa en móvil) ======
      btnSubir.addEventListener('click', ()=> fileAudio.click());
      fileAudio.addEventListener('change', async ()=>{
        const f = fileAudio.files?.[0];
        if (!f) return;
        status.textContent = '⏳ Transcribiendo audio…';
        try {
          const fd = new FormData();
          fd.append('file', f, f.name);
          const r = await fetch(`${API_BASE}/api/whisper`, { method:'POST', body: fd });
          if (!r.ok) {
            let msg = 'HTTP ' + r.status;
            try { const j = await r.json(); if (j?.error) msg += ' · ' + j.error; } catch {}
            throw new Error(msg);
          }
          const { text } = await r.json();
          txtDictado.value = text || '';
          status.textContent = '✅ Transcripción lista. Revisa y corrige si hace falta.';
        } catch(err){
          status.textContent = '❌ Error al transcribir: '+err.message;
        } finally {
          fileAudio.value = '';
        }
      });

      // ====== Redacción policial ======
      $('#btnRedactar').addEventListener('click', async ()=>{
        const texto = (txtDictado.value || '').trim();
        if (!texto) { status.textContent = 'Escribe o dicta algo antes de redactar.'; return; }
        status.textContent = '⏳ Redactando comparecencia…';
        salida.innerHTML = '';
        try {
          const body = JSON.stringify({ texto, filiaciones, objetos });
          const r = await fetch(`${API_BASE}/api/police-draft`, {
            method:'POST',
            headers:{ 'Content-Type':'application/json' },
            body
          });
          if (!r.ok) throw new Error('HTTP '+r.status);
          const { html } = await r.json();
          salida.innerHTML = html || '<em>(Sin contenido devuelto)</em>';
          status.textContent = '✅ Comparecencia generada.';
        } catch(err){
          status.textContent = '❌ Error en redacción: '+err.message;
        }
      });
    })();
  </script>
</body>
</html>
